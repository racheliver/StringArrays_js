/*********************************************
*  Racheli Verechzon,                           *
*  ======================================       *
*         Exercise 2                            *
*  ======================================       *
***********************************************/



/********************************************************************************************
* In this exercise we  wrote functions for handling and analyzing texts.                    *
* You can parse text as follows - for text that consists of words separated by spaces,      *
* we will save a list where for each word we count how many times it appears.               *
* It can be assumed that the words are separated by a single space between word and word,   *
* consisting of large and small English letters, which can be punctuation marks in the text.*
*********************************************************************************************/

/**********************************function parseText****************************************
*The function will receive as a string parameter representing text as described above.      *
*The function returns an array consisting of two-part arrays.                               *
*Each internal array will contain a word from the text and its amount of occurrences.       *
*The order of words in an array does not matter.                                            *
*If the case parameter is equal to true, there will be a difference between the size of the *
*signal and identical words of different letter sizes in different cells in the array       *
*********************************************************************************************/

function parseText(text, letterCase, punc){
var tempText=text,templetterCase=letterCase,tempPunc=punc;

if(parseChecks(tempText,templetterCase,tempPunc)==false)
return;


array=text.split(' ');
withoutDup= RemoveDup(array);

if(letterCase == false)
{
  withoutDup=lowerCase(withoutDup);
  withoutDup=RemoveDup(withoutDup);
  array=lowerCase(array);
}

if(punc == false)
{
  withoutDup=replaceWSpace(withoutDup);
  withoutDup=RemoveDup(withoutDup);
  array=replaceWSpace(array);
}

withoutDup=ByindexRemover(withoutDup);
array=ByindexRemover(array);


length=withoutDup.length;
var arrayCount=new Array(length);
init(arrayCount);


for (var j = 0; j < length; j++) {
for (var i = 0; i < array.length; i++) {
  if(array[i]==withoutDup[j])
  arrayCount[j]++;
  }
}
var tempArray= showByFormat(withoutDup,arrayCount);
return tempArray;
}



/*****************************************function sortText***************************************************************
The function will receive a set of words and expressions as generated by the parseText function and a word boolean       *
parameter. If word is equal to true, the function returns arr when it is sorted in alphabetical order of the words in it,*
and if word is equal to false, the function returns arr by the number of occurrences.In both cases the sorting           *
will be done in ascending order.                                                                                         *
**************************************************************************************************************************/
function sortText(arr, word)
{
  arr=sliceEdge(arr);

/*  var check = sortTextChecksFormat(arr,word);
  if(check==false)
  return;*/

  if(word == true)
  {
    arr=arr.sort(compareByAscii);
    arr=backToOrignal(arr);
    return arr;
  }

  else if(word==false)
  {
    arr=arr.sort(compareByAppearance);
    arr=backToOrignal(arr);
    return arr;
  }
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~private funcrion for Exercise 2A~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**********************function showByFormat************************
The function accepts an array that is not arranged as in the format*
requested in the exercise and therefore shapes the answer as needed*
********************************************************************/
function showByFormat(withoutDup,arrayCount)
{
  var str=new Array(withoutDup.length);
  for (var i = 0; i < withoutDup.length; i++)
    str[i]="";

  str[0]="[";

  for (var i = 0; i < withoutDup.length; i++) {
    str[i]+="['" + "" + withoutDup[i] + "" + "'" + "," +arrayCount[i] +"]";
    if(i===str.length-1)
    str+="]";
  }
    return str;
}



/***************************************************parseChecks*************************************************************
*The function accepts the String and the two Boolean variables and performs several tests to ensure that the input entered  *
*is in accordance with the conditions. Each test will receive an error message accordingly and the function will return true*
*if all tests have passed successfully                                                                                      *
****************************************************************************************************************************/
function parseChecks(text,letterCase,punc)
{
  if((typeof(text)!="string"))
  {
    console.log("1)Please use this format 'string ,boolean, boolean' when you use the function parseText  (this message show at your alert)");
  //  alert("Please use this format 'string ,boolean, boolean' when you use the function parseText");
    return false;
  }

  if(text.length==0)
  {
    console.log("Please *do not* enter a empty string when you use the function parseText  (this message show at your alert)");
  //  alert("Please *do not* enter a empty string when you use the function parseText ");
    return false;
  }

  if((typeof(letterCase))!=="boolean" && (typeof(letterCase)!=="undefined"))
  {
    console.log("2)Please use this format 'string ,boolean, boolean' when you use the function parseText  (this message show at your alert)");
  //  alert("Please use this format 'string ,boolean, boolean' when you use the function parseText");
    return false;
  }
  if((typeof(punc))!=="boolean" && (typeof(punc)!=="undefined"))
  {
    console.log("3)Please use this format 'string ,boolean, boolean' when you use the function parseText  (this message show at your alert)");
  //  alert("Please use this format 'string ,boolean, boolean' when you use the function parseText");
    return;
  }
  var checkEmpteS=false;
  if (/\S/.test(text)) {
    checkEmpteS=true;// string is not empty and not just whitespace
  }
  if( checkEmpteS==false)
  {
    console.log("Please *do not* enter a whitespace when you use the function parseText  (this message show at your alert)");
  //  alert("Please *do not* enter a whitespace  when you use the function parseText ");
    return false;
  }
  return true;
}



/********************function RemoveDup**********************************************************
The function accepts a string array that may be repetitive to the same values, the function     *
clears through the use of the reserved filter function, returns an array without repeated values*
*************************************************************************************************/
function RemoveDup(string){
  uniqueArray = string.filter(function(item, pos) {
      return string.indexOf(item) == pos;
  })
return uniqueArray;
}



/*************************function ByindexRemover********************************************************
The function accepts an array after it has been divided into sections according to spaces. In this case,*
there may be end cases where we encounter a punctuation mark that is left alone after the division      *
 (according to the definition of the exercise, this is not a word and we will remove it)                *
*********************************************************************************************************/
function ByindexRemover(string){
  var index =string.indexOf(".");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf(",");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("&");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("-");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("=");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("/");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("?");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("<");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf(">");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("$");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("%");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf(":");
  if (index > -1) {
    string.splice(index, 1);
  }
  index =string.indexOf("#");
  if (index > -1) {
    string.splice(index, 1);
  }

  return string;

}


function init(array)
{
  for (var i = 0; i < array.length; i++) {
   array[i]=0;
  }
}


/*************function lowerCase***************************************
*The function accepts an array of string and returns only letters with*
***********************************************************************/
function lowerCase(array)
{
  var sorted = array.map(function(value) {
    return value.toLowerCase();
}).sort();
return sorted;
}


/****************************function replaceWSpace*************************************
The function accepts a string array and returns an array with no punctuation.          *
Using the reserved function, we replace each punctuation mark with a single white space*
****************************************************************************************/
function replaceWSpace(array)
{
  for (var i = 0; i < array.length; i++) {
    array[i]=array[i].replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
  }
  return array;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~private funcrion for Exercise 2B~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*****************function compareByAscii***********************************************
The function is aware of the use of sorting. It accepts two objects                    *
a b, and cleans them up to a string only, and only then compares which string is befor *
****************************************************************************************/
function compareByAscii(a, b) {
var tempA,tempB;

tempA = a.slice(a.indexOf("['")+2,a.indexOf("', "));
tempB = b.slice(b.indexOf("['")+2,b.indexOf("', "));

  if (tempA < tempB) {
    return -1;
  }
  if (tempA > tempB) {
    return 1;
  }
  // a must be equal to b
  return 0;
}



/**********************************************************function sliceEdge***************************************************************************
Since the array arrives at the beginning and ends with edges that do not appear in the rest of the objects in the array for convenience, we remove them*
*******************************************************************************************************************************************************/
function sliceEdge(arr)
{
  arr[0]=arr[0].slice(arr[0].indexOf("[")+1);
  arr[arr.length-1]=arr[arr.length-1].slice(0,arr[arr.length-1].indexOf("]")+1);
  return arr;
}


/*********************************************function backToOrignal*************************************************
After changes to the object array we return it to the normal state according to the format requested in the exercise*
*********************************************************************************************************************/
function backToOrignal(arr)
{
  var temp='';
  temp+="["+""+arr[0];
  arr[0]=temp;
  arr[arr.length-1]+=']';
  return arr;
}


/****************************function sortTextChecksFormat********************
Check that the values entered by the user are correct according to the format*
******************************************************************************/
function sortTextChecksFormat(arr,word)
{
  if((typeof(word))!=="boolean")
  {
    console.log("2)Please use this format 'object ,boolean' when you use the function sortText (this message show at your alert)");
  //  alert("Please use this format 'string ,boolean, boolean' when you use the function parseText");
    return false;
  }

  var checkEmpteS=false;
  if (/\S/.test(arr)) {
    checkEmpteS=true;// string is not empty and not just whitespace
  }
  if( checkEmpteS==false)
  {
    console.log("Please *do not* enter a whitespace when you use the function sortText  (this message show at your alert)");
  //  alert("Please *do not* enter a whitespace  when you use the function parseText ");
    return false;
  }
if (sliceAllByString(arr)==false){
  console.log("2)Please use the right format of arr from ex2");
  return false;
}

  return true;
}


/******************function sliceAllByString**********************************
An auxiliary function for additional tests whose format is inserted correctly*
******************************************************************************/
function sliceAllByString(arr){
var  temp = new Array(arr.length);
for (var i = 0; i < (arr.length); i++) {
temp[i] = arr[i].slice(arr.indexOf("['")+3,arr[i].indexOf("', "));
  if (typeof(temp[i])!="string")
  return false;
  }
  return true;
}


/*****************function compareByAppearance************************************************
The function is aware of the use of sorting. It accepts two objects                     *
a b, and cleans them up to a number only, and only then compares which number is bigger *
*****************************************************************************************/
function compareByAppearance(a, b) {
var tempA,tempB;

tempA = a.slice(a.indexOf("', ")+2,a.indexOf("]"));
tempB = b.slice(b.indexOf("', ")+2,b.indexOf("]"));

  if (tempA < tempB) {
    return -1;
  }
  if (tempA > tempB) {
    return 1;
  }
  // a must be equal to b
  return 0;
}
